<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML1.1//END" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
    <head>
        <title> Save the ship! Ditch the reactor! </title>
        <script type="text/javascript">
(function(scope) {
    "use strict";
    var key_left = 37;
    var key_up = 38;
    var key_right = 39;
    var key_down = 40;
    var key_return = 13;

    var empty = " ";
    var wall = "wall";
    var core = "core";
    var red_door = "red door";

    var crane_state_ceiling = "ceiling";
    var crane_state_placing = "placing";
    var crane_state_rising = "rising";

    var crane_update_frequency = 250;
    var max_heat = 10;
    var lead_cooldown = 15;
    var game_state_gameover = "gameover";
    var game_state_victory = "victory";
    var game_state_crane = "crane";

    var game_state = game_state_crane;
    var current_level = 0;
    var levels = [
        { 
            level : [
                [wall, wall , wall , wall , wall , wall , wall , wall , wall],
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, wall , wall , wall , wall , wall , wall , wall , wall],
            ],
        
            leads : [
            ],
            core  : { x : 3, y : 4},
            crane : { x : 4, y : 1 },
            chute : { x : 5, y : 4 },
        },
        { 
            level : [
                [wall, wall , wall , wall , wall , wall , wall , wall , wall],
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty, empty, wall],   
                [wall, empty, wall, empty, empty, empty, empty, empty, wall],   
                [wall, wall , wall , wall , wall , wall , wall , wall , wall],
            ],
        
            leads : [
                { x : 2, y : 3 }
            ],
            core  : { x : 1, y : 4},
            crane : { x : 7, y : 1 },
            chute : { x : 7, y : 4 },
        },
        { 
            level : [
                [wall, wall , wall , wall , wall , wall , wall    , wall , wall],
                [wall, empty, empty, empty, empty, empty, red_door, empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty   , empty, wall],   
                [wall, empty, empty, empty, empty, empty, empty   , empty, wall],   
                [wall, empty, wall , empty, empty, empty, wall    , empty, wall],   
                [wall, wall , wall , wall , wall , wall , wall    , wall , wall],
            ],
        
            leads : [
                    { x : 3, y : 4 }
            ],
            core  : { x : 1, y : 4},
            crane : { x : 1, y : 1 },
            chute : { x : 7, y : 4 },
            red_lock : { x : 5, y : 4 },
            red_key : { x : 4, y : 4 }
        }
    ];
    var level_state = {};

    var keysDown = {};

    function draw_level() {
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(0,0,0)";
        context.fillRect(0, 0, level_state.level[0].length * 50, level_state.level.length*50);
        for (var y = 0; y < level_state.level.length; y++) {
            for (var x = 0; x < level_state.level[y].length; x++) {
                var tile = level_state.level[y][x];
                if (tile === wall) {
                    context.fillStyle = "rgb(127, 127, 255)";
                    context.fillRect(50 * x, 50 * y, 50, 50);
                } else if (tile === empty) {
                    context.fillStyle = "rgb(0, 0, 0)";
                    context.fillRect(50 * x, 50 * y, 50, 50);
                } else if (tile == red_door) {
                    if (level_state.red_lock.locked) {
                        context.fillStyle = "rgb(127, 127, 255)";
                        context.fillRect(50*x, 50*y, 50, 50);
                        context.fillStyle = "rgb(255, 0, 0)";
                        context.fillRect(50*x + 20, 50*y, 10, 50);
                        context.fillRect(50*x, 50*y+20, 50, 10);
                    }
                } else {
                    context.fillStyle = "rgb(255, 0, 0)";
                    context.fillRect(50 * x, 50 * y, 50, 50);
                }
            }
        }
    }

    function draw_crane() {
        var canvas = document.getElementById('game_screen');
        var x = level_state.crane.x * 50;
        var y = level_state.crane.y * 50;
        
        var context = canvas.getContext('2d');
        context.fillStyle="rgb(127,127,127)";
        context.beginPath();
        context.moveTo(x + 20, y);
        context.lineTo(x, y+50);
        context.lineTo(x+50, y+50);
        context.lineTo(x+40, y+40);
        context.lineTo(x+15, y+40);
        context.lineTo(x+30, y);
        context.fill();
    }

    function draw_chute() {
        var canvas = document.getElementById('game_screen');
        var x = level_state.chute.x * 50;
        var y = level_state.chute.y * 50;
        
        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(125, 125, 125)";
        context.fillRect(x, y, 50, 50);

        context.fillStyle = "rgb(0, 0, 100)";
        context.fillRect(x+10, y+10, 30, 30);

        context.fillStyle = "rgb(255, 255, 255)";
        context.fillRect(x + 20, y+15, 2, 2);
        context.fillRect(x + 12, y+28, 2, 2);
        context.fillRect(x + 28, y+32, 2, 2);
        context.fillRect(x + 33, y+19, 2, 2);
    
    }

    function draw_reactor() {
        var canvas = document.getElementById('game_screen');
        var x = level_state.core.x * 50;
        var y = level_state.core.y * 50;

        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(200, 127, 127)";
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x+50, y);
        context.lineTo(x+40, y+10);
        context.lineTo(x+10, y+10);
        context.lineTo(x, y);
        context.fill();

        context.beginPath();
        context.moveTo(x, y+50);
        context.lineTo(x+50, y+50);
        context.lineTo(x+40, y+40);
        context.lineTo(x+10, y+40);
        context.lineTo(x, y+50);
        context.fill();

        context.fillStyle = "rgb(0, 0, 255)";
        context.beginPath();
        context.moveTo(x+25, y+10);
        context.lineTo(x+10, y+25);
        context.lineTo(x+25, y+40);
        context.lineTo(x+40, y+25);
        context.lineTo(x+25, y+10);
        context.fill();
    }

    function draw_control_rods() {
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        for (var i = 0; i < level_state.leads.length; i++) {
            var x = level_state.leads[i].x * 50;
            var y = level_state.leads[i].y * 50;
            context.fillStyle = "rgb(100, 100, 100)";
            context.fillRect(x+5, y+5, 8, 40);
            context.fillRect(x+15, y+5, 8, 40);
            context.fillRect(x+25, y+5, 8, 40);
            context.fillRect(x+35, y+5, 8, 40);
        }
    }

    function draw_reactor_status() {
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(255, 255, 255)";
        context.fillRect(0, 300, 450, 100);
        context.fillStyle = "rgb(0, 0, 0)";
        context.font = "20pt Arial";
        context.fillText("Meltdown -" + (max_heat - level_state.core.heat)+ "s", 10, 350);
    }

    function draw_red_lock() {
        if (level_state.red_lock == undefined) return;
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        var x = level_state.red_lock.x * 50;
        var y = level_state.red_lock.y * 50;

        context.fillStyle = "rgb(255, 0, 0)";
        context.fillRect(x+5, y+5, 40, 40);
        context.fillStyle = "rgb(200, 200, 200)";
        context.fillRect(x+10,y+10,30, 30);
        if (level_state.red_lock.locked) {
            context.fillStyle = "rgb(255, 0, 0)";
        } else {
            context.fillStyle = "rgb(0, 255, 0)";
        }
        context.fillRect(x+15, y+15, 20, 20);
    }

    function draw_red_key() {
        if (level_state.red_key == undefined) return;
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        var x = level_state.red_key.x * 50;
        var y = level_state.red_key.y * 50;

        context.fillStyle = "rgb(255, 0, 0)";
        context.fillRect(x + 5, y + 5, 40, 10);
        context.fillRect(x + 20, y + 5, 10, 40);
    }

    scope.addEventListener("keydown", function(e) {
        keysDown[e.keyCode] = true;
    }, false);

    scope.addEventListener("keyup", function(e) {
        delete keysDown[e.keyCode];
    }, false);

    scope.update = function() {
        if (game_state == game_state_crane) {
            update_in_crane_state();
        } else if (game_state == game_state_gameover) {
            update_in_gameover_state();
        } else if (game_state == game_state_victory) {
            update_in_victory_state();
        }
    }

    function update_in_gameover_state() {
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(255, 0, 0)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "rgb(0, 0, 0)";
        context.fontStyle = "30pt Arial";
        context.fillText("BOOM", 180, 200);
    }

    function update_in_victory_state() {
        var canvas = document.getElementById('game_screen');
        var context = canvas.getContext('2d');
        context.fillStyle = "rgb(0, 255, 0)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "rgb(0, 0, 0)";

        if (current_level + 1 < levels.length) {
            context.fontStyle="20pt Arial";
            context.fillText("Go go there's more to ditch!", 100, 100);
            context.fillText("Press Enter for next level", 100, 200);
            if (key_return in keysDown) {
                delete keysDown[key_return];
                current_level += 1;
                init_level(current_level);
                game_state = game_state_crane;
            }
        } else {
            context.fontStyle = "20pt Arial";
            context.fillText("Phew, that's the last of them!", 100, 100);
            context.fillText("You saved the day!", 100, 200);
        }
    }

    function is_lead(item) {
        for (var i = 0; i < level_state.leads.length; i++) {
            if (level_state.leads[i] == item) {
                return true;
            }
        }
        return false;
    }

    function contains_lead(y, x) {
        for (var i = 0; i < level_state.leads.length; i++) {
            if (level_state.leads[i].x == x && level_state.leads[i].y == y) return true;
        }
        return false;    
    }

    function is_wall(tile) {
        if (tile == wall) return true;
        if (tile == red_door) return level_state.red_lock.locked;
        return false;
    }

    function is_blocking_entity(y, x) {
        if (is_wall(level_state.level[y][x])) return true;
        if (level_state.core.x == x && level_state.core.y == y) return true;
        if (level_state.crane.x == x && level_state.crane.y == y) return true;
        if (level_state.chute.x == x && level_state.chute.y == y) return true;
        if (level_state.red_lock.x == x && level_state.red_lock.y == y) return true;
        if (level_state.red_key.x == x && level_state.red_key.y == y) return true;
        if (contains_lead(y, x)) return true;
        return false;
    }

    function update_in_crane_state() {
        if (level_state.crane.state == crane_state_placing) {
            var now = Date.now();
            if (crane_update_frequency < now - level_state.crane.last_animation_tick) {

                var y_offset_to_check;
                if (level_state.crane.held_item == undefined) {
                    level_state.crane.y += 1;
                    level_state.crane.last_animation_tick = now;
                    var check_y = level_state.crane.y + 1;
                    var check_x = level_state.crane.x;
                    if (check_x == level_state.core.x && check_y == level_state.core.y) {
                        level_state.crane.held_item = level_state.core;
                        level_state.crane.state = crane_state_rising;
                    } else if (check_x == level_state.chute.x && check_y + 1 == level_state.chute.y) {
                        // keep going
                    } else if (level_state.red_lock != undefined && check_x == level_state.red_lock.x && check_y == level_state.red_lock.y) {
                        level_state.crane.state = crane_state_rising;
                    } else if (level_state.red_key != undefined && check_x == level_state.red_key.x && check_y == level_state.red_key.y) {
                        level_state.crane.held_item = level_state.red_key;
                        level_state.crane.state = crane_state_rising;
                    } else if (is_wall(level_state.level[check_y][check_x])) {
                        level_state.crane.state = crane_state_rising;
                    } else if (contains_lead(check_y, check_x)) {
                        for (var i = 0; i < level_state.leads.length; i++) {
                            if (check_x == level_state.leads[i].x && check_y == level_state.leads[i].y) {
                                level_state.crane.state = crane_state_rising;
                                level_state.crane.held_item = level_state.leads[i];
                            }
                        }
                    }
                } else {
                    level_state.crane.y += 1;
                    level_state.crane.held_item.y += 1;
                    level_state.crane.last_animation_tick = now;
                    if (level_state.crane.held_item == level_state.core) {
                        if (level_state.crane.y + 1 == level_state.chute.y && level_state.crane.x == level_state.chute.x) {
                            game_state = game_state_victory;
                        } else if (level_state.crane.y + 2 == level_state.chute.y && level_state.crane.x == level_state.chute.x) {
                            // ignore, keep going
                        } else if (is_wall(level_state.level[level_state.crane.y + 2][level_state.crane.x])) {
                            level_state.crane.held_item = undefined;
                            level_state.crane.state = crane_state_rising;
                        } else if (is_blocking_entity(level_state.crane.y + 2, level_state.crane.x)) {
                            level_state.crane.state = crane_state_rising;
                        }
                    } else if (is_lead(level_state.crane.held_item)) {
                        if (level_state.crane.y + 1 == level_state.core.y && level_state.crane.x == level_state.core.x) {
                            level_state.core.heat -= lead_cooldown;
                            for (var i = 0; i < level_state.leads.length; i++) {
                                if (level_state.leads[i] == level_state.crane.held_item) break;
                            }
                            level_state.leads.splice(i, 1);
                            level_state.crane.held_item = undefined;
                            level_state.crane.state = crane_state_rising;
                        } else if (level_state.crane.y + 2 == level_state.core.y && level_state.crane.x == level_state.core.x) {
                            // empty. keep going
                        } else if (is_wall(level_state.level[level_state.crane.y+2][level_state.crane.x])) {
                            level_state.crane.state = crane_state_rising;
                            level_state.crane.held_item = undefined;
                        } else if (is_blocking_entity(level_state.crane.y+2, level_state.crane.x)) {
                            level_state.crane.state = crane_state_rising;
                        }
                    } else if (level_state.crane.held_item == level_state.red_key) {
                        if (level_state.red_lock.x == level_state.crane.x && level_state.red_lock.y == level_state.crane.y + 1) {
                            delete level_state.red_key;
                            level_state.crane.held_item = undefined;
                            level_state.red_lock.locked = false;
                            level_state.crane.state = crane_state_rising;
                        } else if (is_wall(level_state.level[level_state.crane.y+2][level_state.crane.x])) {
                            level_state.crane.held_item = undefined;
                            level_state.crane.state = crane_state_rising;
                        }
                    }
                }
            }        
        }

        if (level_state.crane.state == crane_state_rising) {
            var now = Date.now();
            if (crane_update_frequency < now - level_state.crane.last_animation_tick) {
                level_state.crane.y -= 1;
                if (level_state.crane.held_item != undefined) {
                    level_state.crane.held_item.y -= 1;
                }
                level_state.crane.last_animation_tick = now;
                if (level_state.crane.y == 1) {
                    level_state.crane.state = crane_state_ceiling;
                }
            }        
        }

        if (key_down in keysDown && level_state.crane.state == crane_state_ceiling) {
            level_state.crane.state = crane_state_placing;
            level_state.core.heat++;
            delete keysDown[key_down];
        }

        if (key_left in keysDown) {
            if (level_state.crane.state == crane_state_ceiling) {
                if (!is_wall(level_state.level[level_state.crane.y][level_state.crane.x -1])) {
                    level_state.crane.x -= 1;
                    level_state.core.heat++;
                    if (level_state.crane.held_item != undefined) {
                        level_state.crane.held_item.x -= 1;
                    }
                }
                delete keysDown[key_left];
            }
        }

        if (key_right in keysDown) {
            if (level_state.crane.state == crane_state_ceiling) {
                if (!is_wall(level_state.level[level_state.crane.y][level_state.crane.x+1])) {
                    level_state.crane.x += 1;
                    level_state.core.heat++;
                    if (level_state.crane.held_item != undefined) {
                        level_state.crane.held_item.x += 1;
                    }
                }
                delete keysDown[key_right];
            }
        }
        draw_level();
        draw_crane();
        draw_reactor();
        draw_reactor_status();
        draw_chute();
        draw_control_rods();
        draw_red_lock();
        draw_red_key();
        if (level_state.core.heat == max_heat) {
            game_state = game_state_gameover;
        }
    }
    
    function shallow_clone(obj) {
        var result = {};
        for (var v in obj) {
            result[v] = obj[v];
        }
        return result;
    }
    function init_level(index) {
        level_state = {};
        level_state.level = levels[index].level.slice(0); 

        level_state.leads = [];
        for (var i = 0; i < levels[index].leads.length; i++) {
            level_state.leads[i] = shallow_clone(levels[index].leads[i]);
        }
        
        level_state.core = shallow_clone(levels[index].core);
        level_state.core.heat = 0;

        level_state.crane = shallow_clone(levels[index].crane);
        level_state.crane.held_item = undefined;
        level_state.crane.state = crane_state_ceiling;
        level_state.crane.last_animation_tick = Date.now();

        level_state.chute = shallow_clone(levels[index].chute);
        level_state.red_lock = shallow_clone(levels[index].red_lock);
        level_state.red_lock.locked = true;
        level_state.red_key = shallow_clone(levels[index].red_key);
    }
    init_level(0);
    window.setInterval(update, 1);}(window))

         </script>
        <style type="text/css">
            canvas { border:1px solid black; }
        </style>
    </head>
    <body>
        <canvas width="450" height="400" id="game_screen"> </canvas>
    </body>
</html>
